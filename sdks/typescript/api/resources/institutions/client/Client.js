"use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Institutions = void 0;
const core = __importStar(require("../../../../core"));
const __1 = require("../../../..");
const url_search_params_1 = __importDefault(require("@ungap/url-search-params"));
const url_join_1 = __importDefault(require("url-join"));
const serializers = __importStar(require("../../../../serialization"));
const errors = __importStar(require("../../../../errors"));
class Institutions {
    options;
    constructor(options) {
        this.options = options;
    }
    /**
     * Look up a financial institution by their country code and either [American Bankers Association routing number](https://www.aba.com/about-us/routing-number), by [International Bank Account Number (IBAN)](https://www.ecbs.org/iban.htm), or by [SWIFT Business Identifier Code (BIC) code](https://www.swift.com/standards/data-standards/bic-business-identifier-code). Optionally, include a list of intermediary institutions that may be necessary to complete international wire transfers.
     * @throws {ApitureApi.Unauthorized}
     * @throws {ApitureApi.Forbidden}
     * @throws {ApitureApi.UnprocessableEntity}
     */
    async lookUpInstitutionByLocator(request) {
        const { locator, locatorType, countryCode, includeIntermediaryInstitutions } = request;
        const _queryParams = new url_search_params_1.default();
        _queryParams.append("locator", locator);
        _queryParams.append("locatorType", locatorType);
        _queryParams.append("countryCode", countryCode);
        if (includeIntermediaryInstitutions != null) {
            _queryParams.append("includeIntermediaryInstitutions", includeIntermediaryInstitutions.toString());
        }
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, "institutionByLocator"),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "API-Key": await core.Supplier.get(this.options.apiKey),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.InstitutionLookupResult.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }
        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new __1.ApitureApi.Unauthorized(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 403:
                    throw new __1.ApitureApi.Forbidden(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 422:
                    throw new __1.ApitureApi.UnprocessableEntity(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                default:
                    throw new errors.ApitureApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApitureApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ApitureApiTimeoutError();
            case "unknown":
                throw new errors.ApitureApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    /**
     * Return a transfer schedule list for this institution.
     * @throws {ApitureApi.Unauthorized}
     * @throws {ApitureApi.Forbidden}
     * @throws {ApitureApi.NotFound}
     * @throws {ApitureApi.UnprocessableEntity}
     */
    async listTransferSchedule(institutionId, request) {
        const { startsOn, endsOn, direction, count, frequency } = request;
        const _queryParams = new url_search_params_1.default();
        _queryParams.append("startsOn", startsOn);
        if (endsOn != null) {
            _queryParams.append("endsOn", endsOn);
        }
        _queryParams.append("direction", direction);
        if (count != null) {
            _queryParams.append("count", count.toString());
        }
        _queryParams.append("frequency", frequency);
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, `institutions/${institutionId}/transferSchedule`),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "API-Key": await core.Supplier.get(this.options.apiKey),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.TransferSchedules.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }
        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new __1.ApitureApi.Unauthorized(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 403:
                    throw new __1.ApitureApi.Forbidden(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 404:
                    throw new __1.ApitureApi.NotFound(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 422:
                    throw new __1.ApitureApi.UnprocessableEntity(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                default:
                    throw new errors.ApitureApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApitureApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ApitureApiTimeoutError();
            case "unknown":
                throw new errors.ApitureApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    /**
     * Return daily cutoff times for different money movement processes at a financial institution. Money movement requests (account to account transfers, ACH, wire transfers, etc.) must be submitted before the cutoff time in order for the financial institution to begin processing the request that day. Some [cutoff time types](#schema-cutoffTimeType) may have multiple cutoff times per day. Cutoff times are very slowly changing data. This is a _conditional operation_ when the `If-None-Match` header is used. If the client has a `getCutoffTimes` response and the `ETag` returned from a previous call to this operation, this operation returns a 304 Not Modified when called again if the cutoff times have not changed.
     * @throws {ApitureApi.BadRequest}
     * @throws {ApitureApi.Unauthorized}
     * @throws {ApitureApi.Forbidden}
     * @throws {ApitureApi.NotFound}
     * @throws {ApitureApi.UnprocessableEntity}
     */
    async getCutoffTimes(institutionId, request = {}) {
        const { timeZoneId, ifNoneMatch } = request;
        const _queryParams = new url_search_params_1.default();
        if (timeZoneId != null) {
            _queryParams.append("timeZoneId", timeZoneId);
        }
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, `institutions/${institutionId}/cutoffTimes`),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "API-Key": await core.Supplier.get(this.options.apiKey),
                "If-None-Match": ifNoneMatch,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.CutoffTimes.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }
        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new __1.ApitureApi.BadRequest(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 401:
                    throw new __1.ApitureApi.Unauthorized(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 403:
                    throw new __1.ApitureApi.Forbidden(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 404:
                    throw new __1.ApitureApi.NotFound(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 422:
                    throw new __1.ApitureApi.UnprocessableEntity(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                default:
                    throw new errors.ApitureApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApitureApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ApitureApiTimeoutError();
            case "unknown":
                throw new errors.ApitureApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    /**
     * Return the transfer date restrictions for a date range and transfer parameters. The result is a list of days and dates that the financial institution does not allow scheduling specific types of transfers. This information provides hints to clients, allowing bank customers to select transfer dates from a calendar picker. However, these dates are not strictly enforced; a transfer can still be scheduled to occur on restricted dates but the financial institution may shift the date when funds are drafted to account for holidays, closures, or to adjust based on the risk level of the funding account.
     * @throws {ApitureApi.BadRequest}
     * @throws {ApitureApi.Unauthorized}
     * @throws {ApitureApi.Forbidden}
     * @throws {ApitureApi.NotFound}
     * @throws {ApitureApi.UnprocessableEntity}
     */
    async getTransferDateRestrictions(institutionId, request = {}) {
        const { startsOn, endsOn, type: type_, risk } = request;
        const _queryParams = new url_search_params_1.default();
        if (startsOn != null) {
            _queryParams.append("startsOn", startsOn);
        }
        if (endsOn != null) {
            _queryParams.append("endsOn", endsOn);
        }
        if (type_ != null) {
            _queryParams.append("type", type_);
        }
        if (risk != null) {
            _queryParams.append("risk", risk);
        }
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, `institutions/${institutionId}/transferDateRestrictions`),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
                "API-Key": await core.Supplier.get(this.options.apiKey),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.TransferDateRestrictions.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }
        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new __1.ApitureApi.BadRequest(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 401:
                    throw new __1.ApitureApi.Unauthorized(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 403:
                    throw new __1.ApitureApi.Forbidden(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 404:
                    throw new __1.ApitureApi.NotFound(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                case 422:
                    throw new __1.ApitureApi.UnprocessableEntity(await serializers.ProblemResponse.parseOrThrow(_response.error.body, {
                        unrecognizedObjectKeys: "passthrough",
                        allowUnrecognizedUnionMembers: true,
                        allowUnrecognizedEnumValues: true,
                    }));
                default:
                    throw new errors.ApitureApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApitureApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.ApitureApiTimeoutError();
            case "unknown":
                throw new errors.ApitureApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    async _getAuthorizationHeader() {
        const value = await core.Supplier.get(this.options.acessToken);
        if (value != null) {
            return `Bearer ${value}`;
        }
        return undefined;
    }
}
exports.Institutions = Institutions;
